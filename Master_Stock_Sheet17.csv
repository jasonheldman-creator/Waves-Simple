# app.py
import math
import pandas as pd
import numpy as np
import streamlit as st

# ---------- PAGE CONFIG ----------
st.set_page_config(
    page_title="WAVES Intelligence – Portfolio Wave Console",
    layout="wide"
)

# ---------- MASTER UNIVERSE LOADER ----------
@st.cache_data(show_spinner=False)
def load_master_universe():
    """
    Load the full equity universe from the single master CSV file.

    The file MUST exist in the root of the repo as:
        Master_Stock_Sheet.cvs.csv
    with columns (case-sensitive):
        Ticker, Company, Weight, Sector, Market Value, Price
    """
    df = pd.read_csv("Master_Stock_Sheet.cvs.csv")

    # Normalize column names we care about
    rename_map = {
        "Ticker": "ticker",
        "Company": "company",
        "Weight": "weight",
        "Sector": "sector",
        "Market Value": "market_value",
        "Price": "price",
    }
    df = df.rename(columns=rename_map)

    # Basic cleaning
    df["weight"] = pd.to_numeric(df["weight"], errors="coerce")
    df["market_value"] = pd.to_numeric(df["market_value"], errors="coerce")
    df["price"] = pd.to_numeric(df["price"], errors="coerce")

    # Drop rows with no ticker
    df = df[df["ticker"].notna() & (df["ticker"].astype(str).str.strip() != "")]
    df = df.reset_index(drop=True)

    return df


MASTER_UNIVERSE = load_master_universe()

# ---------- WAVE DEFINITIONS ----------
# For the meeting: all 8 Waves share the same master universe.
# Later we can add true selection / tilts per Wave; for now the
# differentiation is in the narrative and labels, not the math.

WAVES_CONFIG = {
    "SPX": {
        "label": "SPX – S&P 500 Core Equity Wave",
        "name": "S&P 500 Core Equity Wave",
        "benchmark": "SPY",
        "style": "Core – Large Cap",
        "type": "AI-Managed Wave",
        "mode": "Standard",
        "description": (
            "Live demo of the core S&P 500-style Wave, rendered from the full "
            "master universe using deterministic, rules-based weighting."
        ),
    },
    "QQQ": {
        "label": "QQQ – US Growth & Innovation Wave",
        "name": "US Growth & Innovation Wave",
        "benchmark": "QQQ",
        "style": "Growth – Large Cap",
        "type": "AI-Managed Wave",
        "mode": "Standard",
        "description": (
            "Prototype slot for a QQQ-anchored growth Wave. In this demo it uses the "
            "same master universe; later this slot filters & tilts to growth sectors."
        ),
    },
    "SMGX": {
        "label": "SMGX – Small Cap Growth Wave",
        "name": "Small Cap Growth Wave",
        "benchmark": "Russell 2000",
        "style": "Growth – Small Cap",
        "type": "AI-Managed Wave",
        "mode": "Standard",
        "description": (
            "Prototype slot for a small-cap growth Wave. Currently wired to the "
            "same master universe for holdings visualization."
        ),
    },
    "MID": {
        "label": "MID – Mid Cap Wave",
        "name": "Mid Cap Wave",
        "benchmark": "S&P MidCap 400",
        "style": "Core – Mid Cap",
        "type": "AI-Managed Wave",
        "mode": "Standard",
        "description": (
            "Mid-cap core Wave slot. Uses master universe for this demo; can be "
            "restricted to mid-cap basket in the production engine."
        ),
    },
    "VAL": {
        "label": "VAL – Value Wave",
        "name": "Value Wave",
        "benchmark": "Value Index (Prototype)",
        "style": "Value – Multi-Cap",
        "type": "AI-Managed Wave",
        "mode": "Standard",
        "description": (
            "Value-tilted Wave slot. In this prototype, holdings mirror the master "
            "universe while we focus on the console experience."
        ),
    },
    "DIV": {
        "label": "DIV – Equity Income Wave",
        "name": "Equity Income Wave",
        "benchmark": "High Dividend Index (Prototype)",
        "style": "Income – Multi-Cap",
        "type": "AI-Managed Wave",
        "mode": "Standard",
        "description": (
            "Equity income Wave slot. Production version will filter for dividend "
            "leaders; demo uses the shared master universe."
        ),
    },
    "RWA": {
        "label": "RWA – RWA Income Wave",
        "name": "RWA Income Wave",
        "benchmark": "RWA / Alt Yield (Prototype)",
        "style": "Income – Alternatives",
        "type": "AI-Managed Wave",
        "mode": "Standard",
        "description": (
            "Reserved for tokenized RWA income exposures. For now, this console "
            "reuses the master equity universe so the visuals stay live."
        ),
    },
    "FIN": {
        "label": "FIN – Financial Leadership Wave",
        "name": "Financial Leadership Wave",
        "benchmark": "Financials Index (Prototype)",
        "style": "Sector – Financials",
        "type": "AI-Managed Wave",
        "mode": "Standard",
        "description": (
            "Sector leadership Wave focused on financials. In the prototype, we "
            "still drive holdings from the consolidated master universe."
        ),
    },
}

WAVE_ORDER = ["SPX", "QQQ", "SMGX", "MID", "VAL", "DIV", "RWA", "FIN"]


# ---------- WAVE HELPER FUNCTIONS ----------
def get_wave_universe(wave_id: str) -> pd.DataFrame:
    """
    For the demo we simply return the full master universe for every Wave.

    Later we can implement Wave-specific filters/tilts here (e.g., only tech for growth,
    only financials for FIN, etc.)
    """
    df = MASTER_UNIVERSE.copy()

    # Make sure weights are normalized to 100% just in case
    if "weight" in df.columns and df["weight"].notna().any():
        total_w = df["weight"].sum()
        if total_w > 0:
            df["weight"] = df["weight"] / total_w

    return df


def format_pct(x, decimals=2):
    if pd.isna(x):
        return ""
    return f"{x * 100:.{decimals}f}%"


def format_money(x, decimals=0):
    if pd.isna(x):
        return ""
    return f"${x:,.{decimals}f}"


# ---------- LAYOUT: HEADER ----------
def render_header(wave_id: str):
    cfg = WAVES_CONFIG[wave_id]

    st.markdown(
        "<h2 style='margin-bottom:0.25rem;'>"
        "WAVES INTELLIGENCE™ – PORTFOLIO WAVE CONSOLE"
        "</h2>",
        unsafe_allow_html=True,
    )

    st.markdown(
        f"<h1 style='color:#5ad0ff; margin-top:0.25rem;'>"
        f"{cfg['name']} <span style='font-size:0.7em;'>(LIVE Demo)</span>"
        "</h1>",
        unsafe_allow_html=True,
    )

    meta = (
        f"Mode: **{cfg['mode']}** · "
        f"Benchmark: **{cfg['benchmark']}** · "
        f"Style: **{cfg['style']}** · "
        f"Type: **{cfg['type']}**"
    )
    st.markdown(meta)
    st.markdown(
        cfg["description"]
        + "  \nBelow is a live rendering of the selected Wave’s holdings, "
        "concentration, and basic risk profile – using the same data Franklin uses, "
        "but managed by a small AI-augmented team instead of hundreds of humans."
    )


# ---------- LAYOUT: MAIN DASH ----------
def render_wave_dashboard(wave_id: str):
    cfg = WAVES_CONFIG[wave_id]
    holdings = get_wave_universe(wave_id)

    if holdings.empty:
        st.warning(
            f"Holdings for {cfg['name']} haven’t been wired in yet. "
            f"This Wave slot is live and ready for its CSV link next."
        )
        return

    # Basic stats
    total_holdings = len(holdings)
    largest_weight = holdings["weight"].max()
    wave_aum = holdings["market_value"].sum() if "market_value" in holdings else np.nan

    # ---- TOP SECTION: TABLE + SNAPSHOT ----
    left, right = st.columns([3, 1.7])

    with left:
        st.subheader("Top 10 holdings")
        top10 = holdings.sort_values("weight", ascending=False).head(10).copy()
        top10_display = top10[["ticker", "company", "weight"]].copy()
        top10_display["weight"] = top10_display["weight"].apply(format_pct)

        st.dataframe(
            top10_display,
            hide_index=True,
            use_container_width=True,
        )

        st.caption(
            "Positive 1D moves will render in green, negatives in red once price overlays are live."
        )

    with right:
        st.subheader("Wave snapshot")

        st.markdown(
            f"**Wave:** {wave_id} – {cfg['name']}  \n"
            f"**Total holdings:** {total_holdings:,}  \n"
            f"**Largest position:** {format_pct(largest_weight) if not pd.isna(largest_weight) else 'N/A'}  \n"
            f"**Equity vs Cash:** 100.0% / 0.0%  \n"
            f"**Wave size (demo):** {format_money(wave_aum) if not pd.isna(wave_aum) else 'N/A'}"
        )

    # ---- BOTTOM SECTION: WEIGHT DISTRIBUTION & SECTOR STUBS ----
    st.markdown("---")
    c1, c2, c3 = st.columns([2.2, 2.2, 1.6])

    with c1:
        st.subheader("Top 10 profile – Wave weight distribution")
        if "weight" in holdings.columns:
            # Simple bar chart using Streamlit's built-in chart
            chart_df = top10[["ticker", "weight"]].set_index("ticker")
            st.bar_chart(chart_df)
        else:
            st.info("Weights not available in this CSV.")

    with c2:
        st.subheader("Sector allocation (prototype)")
        if "sector" in holdings.columns and holdings["sector"].notna().any():
            sector_weights = (
                holdings.groupby("sector")["weight"]
                .sum()
                .sort_values(ascending=False)
            )
            sector_chart = sector_weights.head(10)
            st.bar_chart(sector_chart)
        else:
            st.info(
                "No 'Sector' column detected – add one to unlock sector allocation analytics."
            )

    with c3:
        st.subheader("Holding rank curve (demo)")
        if "weight" in holdings.columns:
            weights_sorted = holdings["weight"].sort_values(ascending=False).reset_index(drop=True)
            curve_df = pd.DataFrame(
                {
                    "Rank": np.arange(1, len(weights_sorted) + 1),
                    "Weight": weights_sorted.values,
                }
            ).set_index("Rank")
            st.line_chart(curve_df)
        else:
            st.info("Weights required to render the rank curve.")


# ---------- SIDEBAR ----------
def render_sidebar():
    st.sidebar.markdown("### WAVES Console")
    st.sidebar.markdown("Select a Wave to render its current demo profile:")

    options = [WAVES_CONFIG[w]["label"] for w in WAVE_ORDER]
    default_index = 0
    selection = st.sidebar.selectbox("Select Wave", options, index=default_index)

    # Map label back to wave_id
    reverse_map = {WAVES_CONFIG[w]["label"]: w for w in WAVE_ORDER}
    wave_id = reverse_map[selection]

    st.sidebar.markdown("---")
    st.sidebar.caption(
        "Console is read-only – no live trades are placed. "
        "This demo is wired for institutional-grade oversight."
    )

    return wave_id


# ---------- MAIN APP ----------
def main():
    wave_id = render_sidebar()
    render_header(wave_id)
    render_wave_dashboard(wave_id)


if __name__ == "__main__":
    main()
